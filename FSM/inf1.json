[
  {
    "data-question": {
      "type": "give-input",
      "text": "When a Finite State Machine is given an input, it uses that input to chose which state to move to.<br>Use the buttons below to give the machine an input that moves it to state 3.",
      "allowEpsilon": "false",
      "splitSymbol": "",
      "target": "accept",
      "outputSequence": []
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 93,
            "y": 123,
            "isInit": true,
            "name": "0"
          },
          {
            "id": "B",
            "x": 193,
            "y": 124,
            "name": "1"
          },
          {
            "id": "C",
            "x": 293,
            "y": 125,
            "name": "2"
          },
          {
            "id": "D",
            "x": 393,
            "y": 126,
            "isAcc": true,
            "name": "3"
          }
        ],
        "links": [
          {
            "to": "A",
            "from": "B",
            "input": [
              "B"
            ]
          },
          {
            "to": "B",
            "from": "A",
            "input": [
              "A",
              "B"
            ]
          },
          {
            "to": "C",
            "from": "B",
            "input": [
              "A"
            ]
          },
          {
            "to": "B",
            "from": "C",
            "input": [
              "A"
            ]
          },
          {
            "to": "D",
            "from": "C",
            "input": [
              "B"
            ]
          },
          {
            "to": "D",
            "from": "D",
            "input": [
              "A",
              "B"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "A",
            "B"
          ],
          "allowEpsilon": false
        }
      }
    ],
    "data-options": {},
    "filename": "give-input-intro-to-fsm",
    "name": "Introducing FSMs I",
    "id": "3138777f0f8c4929a12da09c768dd693"
  },
  {
    "data-question": {
      "type": "select-states",
      "text": "If the FSM was in state S2 and was given the input ‘a’, which state would it move to?<br>Select that state and click ‘check’.",
      "allowEpsilon": "false",
      "splitSymbol": "",
      "initialSequence": [
        "a"
      ],
      "targetSequence": [
        "a"
      ]
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 148,
            "y": 124,
            "isInit": true,
            "name": "S1"
          },
          {
            "id": "B",
            "x": 248,
            "y": 124,
            "name": "S2"
          },
          {
            "id": "C",
            "x": 348,
            "y": 124,
            "name": "S3"
          },
          {
            "id": "D",
            "x": 298,
            "y": 211,
            "isAcc": true,
            "name": "S4"
          }
        ],
        "links": [
          {
            "to": "B",
            "from": "A",
            "input": [
              "a",
              "b"
            ]
          },
          {
            "to": "C",
            "from": "B",
            "input": [
              "b"
            ]
          },
          {
            "to": "C",
            "from": "C",
            "input": [
              "b"
            ]
          },
          {
            "to": "D",
            "from": "B",
            "input": [
              "a"
            ]
          },
          {
            "to": "D",
            "from": "C",
            "input": [
              "a"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": false
        }
      }
    ],
    "data-options": {},
    "filename": "select-states-1",
    "name": "Introducing FSMs II",
    "id": "ef31ec761a584ec599ecac607536b1e6"
  },
  {
    "data-question": {
      "type": "select-states",
      "text": "If, starting from the initial state, an input sequence ends with the machine in an <b>accepting state</b>, the machine is said to <b>accept</b> that sequence.<br>Accepting states are shown using a double outline: <img src=\"../img/accepting_bw.svg\" height=\"50\" width=\"50\" alt=\"An example image showing an accepting state composed of two= concentric circles.\" class=\"inline-q-img\">The machine below accepts the string \"ab\". Which state does it end in?",
      "allowEpsilon": "false",
      "splitSymbol": "",
      "initialSequence": [],
      "targetSequence": [
        "a",
        "b"
      ]
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 123,
            "y": 125,
            "isInit": true,
            "name": "S0"
          },
          {
            "id": "B",
            "x": 223,
            "y": 124,
            "name": "S1"
          },
          {
            "id": "C",
            "x": 323,
            "y": 124,
            "isAcc": true,
            "name": "S2"
          }
        ],
        "links": [
          {
            "to": "B",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "C",
            "from": "B",
            "input": [
              "a",
              "b"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": true
        }
      }
    ],
    "data-options": {},
    "filename": "select-states-2-accepting-states",
    "name": "Accepting states I",
    "id": "0286265dba1f4e348ea4ff8b6dd7797f"
  },
  {
    "data-question": {
      "type": "give-list",
      "text": "A finite state machine accepts a sequence if that sequence ends in an accepting state. In this example, states ‘3’ and ‘4’  are accepting states.<br>The machine accepts 2 sequences. One is \"aa\", give the other.",
      "lengths": [
        2,
        2
      ],
      "prefill": {
        "0": "aa"
      },
      "splitSymbol": ""
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 83,
            "y": 160,
            "isInit": true,
            "name": "1"
          },
          {
            "id": "B",
            "x": 232,
            "y": 168,
            "name": "2"
          },
          {
            "id": "C",
            "x": 372,
            "y": 224,
            "isAcc": true,
            "name": "3"
          },
          {
            "id": "D",
            "x": 349,
            "y": 73,
            "isAcc": true,
            "name": "4"
          }
        ],
        "links": [
          {
            "to": "B",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "D",
            "from": "B",
            "input": [
              "a"
            ]
          },
          {
            "to": "C",
            "from": "B",
            "input": [
              "b"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ]
        }
      }
    ],
    "data-options": {},
    "filename": "give-list-1",
    "name": "Accepting states II",
    "id": "f6161c3cac004a418b340bb2eebd79f8"
  },
  {
    "data-question": {
      "type": "give-list",
      "text": "FSMs can be in a particular state more than once. The machine shown accepts<br>inputs consisting of N times '<i>a</i>' followed by '<i>bb</i>' where N is a multiple of 3.<br><b>For each of the lengths given, give an input the machine will accept</b>",
      "allowEpsilon": "false",
      "splitSymbol": "",
      "lengths": [
        2,
        5,
        8
      ],
      "prefill": {
        "0": "bb"
      }
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 161,
            "y": 127,
            "isInit": true,
            "name": "0"
          },
          {
            "id": "B",
            "x": 261,
            "y": 130,
            "name": "1"
          },
          {
            "id": "C",
            "x": 214,
            "y": 42,
            "name": "2"
          },
          {
            "id": "D",
            "x": 217,
            "y": 210
          },
          {
            "id": "E",
            "x": 316,
            "y": 226,
            "isAcc": true
          }
        ],
        "links": [
          {
            "to": "B",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "C",
            "from": "B",
            "input": [
              "a"
            ]
          },
          {
            "to": "A",
            "from": "C",
            "input": [
              "a"
            ]
          },
          {
            "to": "D",
            "from": "A",
            "input": [
              "b"
            ]
          },
          {
            "to": "E",
            "from": "D",
            "input": [
              "b"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": false
        }
      }
    ],
    "data-options": {},
    "filename": "give-list-cyles",
    "name": "Introducing cycles",
    "id": "d28fa5713e994235a854cb78c71f4596"
  },
  {
    "data-question": {
      "type": "satisfy-list",
      "text": "Modify the machine below so that it accepts sequences consisting of an <b>odd number of 'a's followed by 'bc'.</b><br><b>Hint</b>: to create links between states, select the link tool and then click source state and the target state.",
      "allowEpsilon": "false",
      "splitSymbol": "",
      "shouldAccept": [
        "abc",
        "aaabc",
        "aaaaabc",
        "aaaaaaabc"
      ],
      "shouldReject": [
        "a",
        "ab",
        "aabc",
        "bc"
      ]
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 98,
            "y": 129,
            "isInit": true
          },
          {
            "id": "B",
            "x": 198,
            "y": 129
          },
          {
            "id": "C",
            "x": 298,
            "y": 129
          },
          {
            "id": "D",
            "x": 398,
            "y": 129,
            "isAcc": true
          }
        ],
        "links": [],
        "attributes": {
          "alphabet": [
            "a",
            "b",
            "c"
          ],
          "allowEpsilon": false
        }
      }
    ],
    "data-options": {},
    "filename": "machine-construction-1",
    "name": "Machine construction I",
    "id": "5e676df3559d4391b728134568f619ba"
  },
  {
    "data-question": {
      "type": "satisfy-list",
      "text": "Modify the FSM below to accept the strings on the left but reject the strings on the right.",
      "allowEpsilon": "false",
      "splitSymbol": "",
      "shouldAccept": [
        "aa",
        "aba",
        "abba",
        "aaa",
        "abaa"
      ],
      "shouldReject": [
        "",
        "a",
        "a",
        "aaba"
      ]
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 93,
            "y": 130,
            "isInit": true,
            "name": "1"
          },
          {
            "id": "B",
            "x": 193,
            "y": 130,
            "name": "2"
          }
        ],
        "links": [
          {
            "to": "B",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "B",
            "from": "B",
            "input": [
              "b"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": false
        }
      }
    ],
    "data-options": {},
    "filename": "machine-construction-2",
    "name": "Machine construction II",
    "id": "c828299302cb42939462ca5788007755"
  },
  {
    "data-question": {
      "type": "select-states",
      "text": "Instead of operating on single characters, FSMs will sometimes treat longer strings as a single token. This is often used when modelling control systems. <br>The machine below is a simplified representation of a self-service checkout.<br><b>Select the state</b> that the machine would be in after the input: start, scan_item, bag_item, scan_item, bag_item.",
      "allowEpsilon": "false",
      "splitSymbol": " ",
      "initialSequence": [],
      "targetSequence": [
        "start",
        "scan_item",
        "bag_item",
        "scan_item",
        "bag_item"
      ]
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 91,
            "y": 128,
            "isInit": true
          },
          {
            "id": "B",
            "x": 138,
            "y": 216
          },
          {
            "id": "C",
            "x": 191,
            "y": 131
          },
          {
            "id": "D",
            "x": 291,
            "y": 133
          },
          {
            "id": "E",
            "x": 390,
            "y": 128
          },
          {
            "id": "F",
            "x": 343,
            "y": 218,
            "isAcc": true
          }
        ],
        "links": [
          {
            "to": "C",
            "from": "A",
            "input": [
              "scan_item"
            ]
          },
          {
            "to": "B",
            "from": "A",
            "input": [
              "start"
            ]
          },
          {
            "to": "C",
            "from": "B",
            "input": [
              "scan_item"
            ]
          },
          {
            "to": "D",
            "from": "C",
            "input": [
              "bag_item"
            ]
          },
          {
            "to": "F",
            "from": "D",
            "input": [
              "pay"
            ]
          },
          {
            "to": "D",
            "from": "E",
            "input": [
              "bag_item"
            ]
          },
          {
            "to": "E",
            "from": "D",
            "input": [
              "scan_item"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "start",
            "scan_item",
            "bag_item",
            "pay"
          ],
          "allowEpsilon": false
        }
      }
    ],
    "data-options": {},
    "filename": "select-states-self-service",
    "name": "Using longer tokens",
    "id": "b88a6ceffd0a40ef9413973995a50ec2"
  },
  {
    "data-question": {
      "type": "satisfy-list",
      "text": "Design a FSM to represent the logic of a vending machine. It sells water for 40p and Irn-Bru for 50p. It accepts 10p and 20p coins.<br>The user is not required to enter exact money - eg if they enter 60p they should still be able to purchase water.",
      "allowEpsilon": "false",
      "splitSymbol": ", ",
      "shouldAccept": [
        "10p, 10p, 10p, 10p, 10p, Irn-Bru",
        "20p, 20p, Water",
        "10p, 20p, 20p, Irn-Bru",
        "20p, 20p, 20p, Water",
        "10p, 10p, 20p, 10p, Water"
      ],
      "shouldReject": [
        "",
        "10p, 10p, Water",
        "10p, 10p, 20p, Water, Water"
      ]
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 52,
            "y": 196,
            "isInit": true,
            "name": "0p"
          },
          {
            "id": "B",
            "x": 152,
            "y": 196,
            "name": "20p"
          },
          {
            "id": "C",
            "x": 103,
            "y": 109,
            "name": "10p"
          }
        ],
        "links": [
          {
            "to": "B",
            "from": "A",
            "input": [
              "20p"
            ]
          },
          {
            "to": "C",
            "from": "A",
            "input": [
              "10p"
            ]
          },
          {
            "to": "B",
            "from": "C",
            "input": [
              "10p"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "10p",
            "20p",
            "Water",
            "Irn-Bru"
          ],
          "allowEpsilon": false
        }
      }
    ],
    "data-options": {},
    "filename": "vending-machine-1",
    "name": "Vending machine acceptor",
    "id": "159d34df52fc4d248053f6623f408b71"
  },
  {
    "data-question": {
      "type": "select-states",
      "text": "A finite state machine is <b>non-deterministic</b> if it has more than one possible transition out of a state for a particular input symbol.<br>When there is more than one possible path, all possible paths are considered simultaneously.<br><br>The machine below could be in 3 possible states after receiving the input \"<b>y, y</b>\". Select them.",
      "allowEpsilon": "false",
      "splitSymbol": ", ",
      "initialSequence": [],
      "targetSequence": [
        "y",
        "y"
      ]
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 123,
            "y": 148,
            "isInit": true,
            "name": "a"
          },
          {
            "id": "B",
            "x": 223,
            "y": 147,
            "name": "b"
          },
          {
            "id": "C",
            "x": 289,
            "y": 72,
            "name": "c"
          },
          {
            "id": "D",
            "x": 323,
            "y": 147,
            "isAcc": true,
            "name": "d"
          },
          {
            "id": "E",
            "x": 299,
            "y": 212,
            "name": "e"
          }
        ],
        "links": [
          {
            "to": "A",
            "from": "A",
            "input": [
              "y"
            ]
          },
          {
            "to": "B",
            "from": "A",
            "input": [
              "y"
            ]
          },
          {
            "to": "A",
            "from": "B",
            "input": [
              "y"
            ]
          },
          {
            "to": "C",
            "from": "B",
            "input": [
              "z"
            ]
          },
          {
            "to": "D",
            "from": "B",
            "input": [
              "x"
            ]
          },
          {
            "to": "E",
            "from": "B",
            "input": [
              "x",
              "y"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "x",
            "y",
            "z"
          ],
          "allowEpsilon": false
        }
      }
    ],
    "data-options": {},
    "filename": "select-states-4-nfa-intro",
    "name": "Nondeterministic transitions I",
    "id": "f58fd145585a48d695059e2348778331"
  },
  {
    "data-question": {
      "type": "does-accept",
      "text": "A non-deterministic finite state machine accepts a sequence if there is <b>at least one path</b> for that sequence that <b>ends in an accepting state</b>.<br>For the sequences below, tick those that the machine would accept.",
      "allowEpsilon": "false",
      "splitSymbol": "",
      "sequences": [
        "aaab",
        "ac",
        "baabc",
        "abb",
        "abba",
        "aaaabcb"
      ]
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 101,
            "y": 129,
            "isInit": true,
            "name": "0"
          },
          {
            "id": "B",
            "x": 201,
            "y": 129,
            "name": "1"
          },
          {
            "id": "C",
            "x": 301,
            "y": 129,
            "isAcc": true,
            "name": "3"
          },
          {
            "id": "D",
            "x": 401,
            "y": 129,
            "name": "4"
          },
          {
            "id": "E",
            "x": 254,
            "y": 213,
            "name": "2"
          }
        ],
        "links": [
          {
            "to": "B",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "C",
            "from": "B",
            "input": [
              "b"
            ]
          },
          {
            "to": "E",
            "from": "B",
            "input": [
              "b"
            ]
          },
          {
            "to": "C",
            "from": "E",
            "input": [
              "c"
            ]
          },
          {
            "to": "D",
            "from": "C",
            "input": [
              "b"
            ]
          },
          {
            "to": "C",
            "from": "D",
            "input": [
              "a"
            ]
          },
          {
            "to": "D",
            "from": "D",
            "input": [
              "a"
            ]
          },
          {
            "to": "A",
            "from": "A",
            "input": [
              "a",
              "b"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "a",
            "b",
            "c"
          ],
          "allowEpsilon": false
        }
      }
    ],
    "data-options": {},
    "filename": "does-accept-nfa",
    "name": "Nondeterministic transitions II",
    "id": "cb0c308c26544603b125f5ff0d962d2f"
  },
  {
    "data-question": {
      "type": "give-list",
      "text": "For each of the lengths given, give a sequence that the Finite State Machine will accept.",
      "allowEpsilon": "false",
      "splitSymbol": "",
      "lengths": [
        3,
        7
      ],
      "prefill": {}
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 115,
            "y": 195,
            "isInit": true,
            "name": "1"
          },
          {
            "id": "B",
            "x": 215,
            "y": 195,
            "name": "2"
          },
          {
            "id": "C",
            "x": 315,
            "y": 194
          },
          {
            "id": "D",
            "x": 415,
            "y": 195,
            "isAcc": true
          },
          {
            "id": "E",
            "x": 114,
            "y": 95
          }
        ],
        "links": [
          {
            "to": "B",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "C",
            "from": "B",
            "input": [
              "b"
            ]
          },
          {
            "to": "E",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "A",
            "from": "E",
            "input": [
              "b"
            ]
          },
          {
            "to": "D",
            "from": "C",
            "input": [
              "b"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": false
        }
      }
    ],
    "data-options": {},
    "filename": "nondeterministic-transitions-3",
    "name": "Nondeterministic Transitions III",
    "id": "48c1323783f7429b9ae5fb03d10387d4"
  },
  {
    "data-question": {
      "type": "select-states",
      "text": "As well as allowing multiple paths out of a state for a single input, non-deterministic finite automata also allow <b>epsilon transitions</b>. <br>These are special transitions (shown as ε) that can be taken <b>without consuming any input</b>. <br>The machine below can end in two different states for the input \"a\". Select them.",
      "allowEpsilon": "true",
      "splitSymbol": " ",
      "initialSequence": [],
      "targetSequence": [
        "a"
      ]
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 106,
            "y": 128,
            "isInit": true
          },
          {
            "id": "B",
            "x": 206,
            "y": 128
          },
          {
            "id": "C",
            "x": 306,
            "y": 128
          }
        ],
        "links": [
          {
            "to": "B",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "C",
            "from": "B",
            "hasEps": true
          }
        ],
        "attributes": {
          "alphabet": [
            "a"
          ],
          "allowEpsilon": true
        }
      }
    ],
    "data-options": {},
    "filename": "select-states-intro-to-epsilon",
    "name": "Introducing ε transitions",
    "id": "66fefee9f6ba4d1b96c1efc2b213d3e6"
  },
  {
    "data-question": {
      "type": "satisfy-list",
      "text": "Epsilon transitions are useful for combining machines. Below are two machine fragments that accept \"abc\" and \"aac\", combine them using epsilon transitions to form a single machine that accepts both \"abc\" and \"aac\".",
      "allowEpsilon": "true",
      "splitSymbol": "",
      "shouldAccept": [
        "abc",
        "aac"
      ],
      "shouldReject": [
        "",
        "a",
        "b",
        "abcaac",
        "bc",
        "ac"
      ]
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 127,
            "y": 39
          },
          {
            "id": "B",
            "x": 227,
            "y": 39
          },
          {
            "id": "C",
            "x": 327,
            "y": 39
          },
          {
            "id": "D",
            "x": 427,
            "y": 39,
            "isAcc": true
          },
          {
            "id": "E",
            "x": 426,
            "y": 240,
            "isAcc": true
          },
          {
            "id": "F",
            "x": 83,
            "y": 140,
            "isInit": true,
            "name": "S"
          },
          {
            "id": "G",
            "x": 326,
            "y": 240
          },
          {
            "id": "H",
            "x": 226,
            "y": 240
          },
          {
            "id": "I",
            "x": 126,
            "y": 240
          }
        ],
        "links": [
          {
            "to": "B",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "C",
            "from": "B",
            "input": [
              "b"
            ]
          },
          {
            "to": "D",
            "from": "C",
            "input": [
              "c"
            ]
          },
          {
            "to": "H",
            "from": "I",
            "input": [
              "a"
            ]
          },
          {
            "to": "G",
            "from": "H",
            "input": [
              "a"
            ]
          },
          {
            "to": "E",
            "from": "G",
            "input": [
              "c"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "a",
            "b",
            "c"
          ],
          "allowEpsilon": true
        }
      }
    ],
    "data-options": {},
    "filename": "combining-with-epsilon",
    "name": "Combining machines with ε transitions",
    "id": "057696acdc1143c3b7eb3cdf6437a4bb"
  },
  {
    "data-question": {
      "type": "dfa-convert",
      "text": "All <b>non-deterministic</b> finite state machines (NFA) can be converted into equivalent <b>deterministic</b> machines (DFA).<br>This can be done using subset construction, where the DFA is given a state for each reachable combination of states in the NFA.<br>Follow the instructions below to convert the NFA on the left.",
      "allowEpsilon": "false",
      "splitSymbol": ""
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 102,
            "y": 132,
            "isInit": true,
            "name": "Q1"
          },
          {
            "id": "B",
            "x": 202,
            "y": 124,
            "name": "Q3"
          },
          {
            "id": "C",
            "x": 145,
            "y": 42,
            "name": "Q2"
          },
          {
            "id": "D",
            "x": 302,
            "y": 130,
            "isAcc": true,
            "name": "Q4"
          }
        ],
        "links": [
          {
            "to": "C",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "B",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "B",
            "from": "C",
            "input": [
              "b"
            ]
          },
          {
            "to": "D",
            "from": "B",
            "input": [
              "a"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": false
        }
      },
      {
        "nodes": [
          {
            "id": "A",
            "x": 60,
            "y": 112,
            "isInit": true,
            "name": "{Q1}"
          }
        ],
        "links": [],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": false
        }
      }
    ],
    "data-options": {},
    "filename": "dfa-convert-1",
    "name": "Conversion to DFA I",
    "id": "b07d3a54edfa4287a1753564b1fca583"
  },
  {
    "data-question": {
      "type": "dfa-convert",
      "text": "Follow the instructions below to construct a DFA equivalent to the NFA on the left.",
      "allowEpsilon": "true",
      "splitSymbol": ""
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 148,
            "y": 103,
            "isInit": true,
            "name": "Q1"
          },
          {
            "id": "B",
            "x": 229,
            "y": 44,
            "name": "Q4"
          },
          {
            "id": "C",
            "x": 239,
            "y": 144,
            "isAcc": true,
            "name": "Q5"
          },
          {
            "id": "D",
            "x": 158,
            "y": 202,
            "name": "Q3"
          },
          {
            "id": "E",
            "x": 67,
            "y": 162,
            "name": "Q2"
          }
        ],
        "links": [
          {
            "to": "A",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "B",
            "from": "A",
            "input": [
              "a",
              "b"
            ]
          },
          {
            "to": "C",
            "from": "B",
            "input": [
              "b"
            ]
          },
          {
            "to": "C",
            "from": "A",
            "input": [
              "a",
              "b"
            ]
          },
          {
            "to": "D",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "C",
            "from": "D",
            "input": [
              "b"
            ]
          },
          {
            "to": "E",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "D",
            "from": "E",
            "input": [
              "b"
            ]
          },
          {
            "to": "E",
            "from": "D",
            "input": [
              "a"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": false
        }
      },
      {
        "nodes": [
          {
            "id": "A",
            "x": 60,
            "y": 112,
            "isInit": true,
            "name": "{Q1}"
          }
        ],
        "links": [],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": false
        }
      }
    ],
    "data-options": {},
    "filename": "dfa-convert-2",
    "name": "Conversion to DFA II",
    "id": "36422a89ab2f4fa4bd466b05b7467bfe"
  },
  {
    "data-question": {
      "type": "dfa-convert",
      "text": "When the NFA being converted contains ε-transitions, these must be taken into account when determining which states are reachable for particular input.<br>If a state can be reached using that input with any number of ε-transitions before or after it then it is considered reachable for this conversion.",
      "allowEpsilon": "true",
      "splitSymbol": ""
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 90,
            "y": 102,
            "isAcc": true,
            "isInit": true,
            "name": "Q1"
          },
          {
            "id": "B",
            "x": 73,
            "y": 203,
            "isInit": true,
            "name": "Q2"
          },
          {
            "id": "C",
            "x": 179,
            "y": 57,
            "name": "Q3"
          },
          {
            "id": "D",
            "x": 165,
            "y": 244,
            "name": "Q4"
          },
          {
            "id": "E",
            "x": 275,
            "y": 89,
            "name": "Q5"
          },
          {
            "id": "F",
            "x": 264,
            "y": 225,
            "name": "Q6"
          },
          {
            "id": "G",
            "x": 199,
            "y": 152,
            "isAcc": true,
            "name": "Q7"
          }
        ],
        "links": [
          {
            "to": "C",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "D",
            "from": "B",
            "input": [
              "b"
            ]
          },
          {
            "to": "E",
            "from": "C",
            "input": [
              "b"
            ]
          },
          {
            "to": "F",
            "from": "D",
            "input": [
              "a"
            ]
          },
          {
            "to": "E",
            "from": "E",
            "input": [
              "b"
            ]
          },
          {
            "to": "F",
            "from": "F",
            "input": [
              "a"
            ]
          },
          {
            "to": "G",
            "from": "E",
            "input": [
              "b"
            ]
          },
          {
            "to": "G",
            "from": "F",
            "hasEps": true
          },
          {
            "to": "D",
            "from": "G",
            "hasEps": true
          },
          {
            "to": "C",
            "from": "G",
            "hasEps": true
          }
        ],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": true
        }
      },
      {
        "nodes": [
          {
            "id": "A",
            "x": 76,
            "y": 130,
            "isAcc": true,
            "isInit": true,
            "name": "{Q1, Q2}"
          }
        ],
        "links": [],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": true
        }
      }
    ],
    "data-options": {},
    "filename": "dfa-convert-3",
    "name": "Conversion to DFA III",
    "id": "fa25498448cf429fa6f757b4f44eef6f"
  },
  {
    "data-question": {
      "type": "satisfy-definition",
      "text": "A formal language is used to precisely define a Finite State Machine. <br>A machine <em>M</em> consists of:<br><em>Q</em>: the set of states,<br>Σ: the alphabet of the machine - all symbols the machine can process,<br><em>s</em><sub>0</sub>: the set of initial states of the machine<br><em>F</em>: the set of the machine's accepting states.<br>δ: The set of transitions the machine allows, with each transition in the form (source state, input symbol, end state).<br><br>Construct the Finite State Machine defined by<br><br><em>Q</em> = {1,2,3,4}<br><em>Σ</em> = {a,b,c}<br><em>s<sub>0</sub></em> = {1}<br><em>F</em> = {3,4}<br><em>δ</em> = {(1,a,2),(2,b,3),(2,c,4),(3,b,2)}",
      "allowEpsilon": "false",
      "splitSymbol": "",
      "definition": {
        "states": [
          "1",
          "2",
          "3",
          "4"
        ],
        "alphabet": [
          "a",
          "b",
          "c"
        ],
        "initialStates": [
          "1"
        ],
        "acceptingStates": [
          "3",
          "4"
        ],
        "links": [
          {
            "to": "2",
            "from": "1",
            "symbol": "a"
          },
          {
            "to": "3",
            "from": "2",
            "symbol": "b"
          },
          {
            "to": "4",
            "from": "2",
            "symbol": "c"
          },
          {
            "to": "2",
            "from": "3",
            "symbol": "b"
          }
        ]
      }
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 100,
            "y": 125,
            "isInit": true,
            "name": "1"
          }
        ],
        "links": [],
        "attributes": {
          "alphabet": [
            "a",
            "b",
            "c"
          ],
          "allowEpsilon": false
        }
      }
    ],
    "data-options": {},
    "filename": "satisfy-definition-1",
    "name": "Formal machine definition I",
    "id": "df18d7c3bf5146c58d0c6c56276ba583"
  },
  {
    "data-question": {
      "type": "satisfy-definition",
      "text": "<em>Q</em> = {1,2,3,4,5,6,7,8}<br><em>Σ</em> = {1,2}<br><em>s<sub>0</sub></em> = {1}<br><em>F</em> = {8}<br><em>δ</em> = {(1,1,2),(1,1,4),(2,2,2),(2,2,3),(3,1,3),(3,ε,8),(4,1,5),(4,2,6),(5,1,5),(5,2,5),(6,1,4),(6,1,6),(6,2,7),(7,ε,8)}<br>",
      "allowEpsilon": "true",
      "splitSymbol": ", ",
      "definition": {
        "states": [
          "1",
          "3",
          "2",
          "4",
          "5",
          "7",
          "6",
          "8"
        ],
        "alphabet": [
          "1",
          "2"
        ],
        "initialStates": [
          "1"
        ],
        "acceptingStates": [
          "8"
        ],
        "links": [
          {
            "to": "2",
            "from": "1",
            "symbol": "1"
          },
          {
            "to": "4",
            "from": "1",
            "symbol": "1"
          },
          {
            "to": "2",
            "from": "2",
            "symbol": "2"
          },
          {
            "to": "3",
            "from": "2",
            "symbol": "2"
          },
          {
            "to": "3",
            "from": "3",
            "symbol": "1"
          },
          {
            "to": "8",
            "from": "3",
            "symbol": "ε",
            "epsilon": true
          },
          {
            "to": "5",
            "from": "4",
            "symbol": "1"
          },
          {
            "to": "5",
            "from": "5",
            "symbol": "1"
          },
          {
            "to": "5",
            "from": "5",
            "symbol": "2"
          },
          {
            "to": "6",
            "from": "4",
            "symbol": "2"
          },
          {
            "to": "4",
            "from": "6",
            "symbol": "1"
          },
          {
            "to": "6",
            "from": "6",
            "symbol": "1"
          },
          {
            "to": "7",
            "from": "6",
            "symbol": "2"
          },
          {
            "to": "8",
            "from": "7",
            "symbol": "ε",
            "epsilon": true
          }
        ]
      }
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 76,
            "y": 150,
            "isInit": true,
            "name": "1"
          },
          {
            "id": "B",
            "x": 169,
            "y": 63,
            "name": "2"
          },
          {
            "id": "C",
            "x": 312,
            "y": 65,
            "name": "3"
          },
          {
            "id": "D",
            "x": 414,
            "y": 155,
            "name": "8"
          },
          {
            "id": "E",
            "x": 121,
            "y": 238,
            "name": "4"
          },
          {
            "id": "F",
            "x": 231,
            "y": 152,
            "name": "6"
          },
          {
            "id": "G",
            "x": 240,
            "y": 276,
            "name": "5"
          },
          {
            "id": "H",
            "x": 358,
            "y": 220,
            "name": "7"
          }
        ],
        "links": [],
        "attributes": {
          "alphabet": [
            "1",
            "2"
          ],
          "allowEpsilon": true
        }
      }
    ],
    "data-options": {},
    "filename": "satisfy-definition-2-2013-14-resit",
    "name": "Formal machine definition II",
    "id": "4f262a9d7e774fd7a454468d3a5e794b"
  },
  {
    "data-question": {
      "type": "give-equivalent",
      "text": "Regular expressions can be used to define languages accepted by finite state machines. <br>One operator used in regular expressions is *, the Kleene star. It means that the symbol before it must appear 0 or more times.<br>For example,<b> a*b*</b> means 'a' zero or more times followed by 'b' zero or more time. This language includes the empty string, \"a\", \"b\", \"ab\", \"aa\", \"bb\", etc.<br>Construct a finite state machine which is accepts the language definined by the regular expression <b>a*b*</b>",
      "allowEpsilon": "true",
      "splitSymbol": "",
      "targetMachineSpec": {
        "nodes": [
          {
            "id": "A",
            "x": 78,
            "y": 123,
            "isAcc": true,
            "isInit": true,
            "name": "S"
          },
          {
            "id": "B",
            "x": 178,
            "y": 118,
            "isAcc": true
          }
        ],
        "links": [
          {
            "to": "A",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "B",
            "from": "A",
            "input": [
              "b"
            ]
          },
          {
            "to": "B",
            "from": "B",
            "input": [
              "b"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "a",
            "b",
            "c"
          ],
          "allowEpsilon": true
        }
      }
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 83,
            "y": 123,
            "isInit": true
          }
        ],
        "links": [],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": true
        }
      }
    ],
    "data-options": {},
    "filename": "kleene-star-1",
    "name": "Regular expressions - Kleene star I",
    "id": "7e3194c04ffb4928916717d2dd5d8fdb"
  },
  {
    "data-question": {
      "type": "give-equivalent",
      "text": "Another regular expression operator is <b>or</b>, written as a vertical bar: |. <br>For example <b>aa|bb</b> matches \"aa\" and \"bb\" but not \"ab\"<br>Construct a finite state machine that accepts the language described by <b>aa|bb</b>",
      "allowEpsilon": "true",
      "splitSymbol": "",
      "targetMachineSpec": {
        "nodes": [
          {
            "id": "A",
            "x": 107,
            "y": 132,
            "isInit": true
          },
          {
            "id": "B",
            "x": 207,
            "y": 130
          },
          {
            "id": "C",
            "x": 307,
            "y": 129,
            "isAcc": true
          },
          {
            "id": "D",
            "x": 179,
            "y": 201
          },
          {
            "id": "E",
            "x": 279,
            "y": 202,
            "isAcc": true
          }
        ],
        "links": [
          {
            "to": "B",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "C",
            "from": "B",
            "input": [
              "a"
            ]
          },
          {
            "to": "D",
            "from": "A",
            "input": [
              "b"
            ]
          },
          {
            "to": "E",
            "from": "D",
            "input": [
              "b"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": true
        }
      }
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 106,
            "y": 128,
            "isInit": true
          }
        ],
        "links": [],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": true
        }
      }
    ],
    "data-options": {},
    "filename": "give-equivalent-intro-to-or",
    "name": "Regular expressions - Boolean or",
    "id": "abc16525672948a5902a53cd1342a6e9"
  },
  {
    "data-question": {
      "type": "give-equivalent",
      "text": "When the Kleene Star (*) is applied to bracketed expression, it is not necessary for each of the zero<br> or more matches of the expression to be identical, so long as they each match the expression.<br><br>For example <b>(ab|c)*</b> matches \"cab\", with the bracketed expression first accepting \"c\" and then \"ab\".<br>Construct a finite state machine that accepts the language defined by the regular expression <b>(ab|c)*</b>",
      "allowEpsilon": "true",
      "splitSymbol": "",
      "targetMachineSpec": {
        "nodes": [
          {
            "id": "A",
            "x": 156,
            "y": 98,
            "isAcc": true,
            "isInit": true
          },
          {
            "id": "B",
            "x": 211,
            "y": 181
          },
          {
            "id": "C",
            "x": 256,
            "y": 92,
            "isAcc": true
          }
        ],
        "links": [
          {
            "to": "B",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "C",
            "from": "B",
            "input": [
              "b"
            ]
          },
          {
            "to": "A",
            "from": "C",
            "hasEps": true
          },
          {
            "to": "C",
            "from": "A",
            "input": [
              "c"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "a",
            "b",
            "c"
          ],
          "allowEpsilon": true
        }
      }
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 106,
            "y": 128,
            "isInit": true
          }
        ],
        "links": [],
        "attributes": {
          "alphabet": [
            "a",
            "b",
            "c"
          ],
          "allowEpsilon": true
        }
      }
    ],
    "data-options": {},
    "filename": "give-equivalent-kleene-bracket",
    "name": "Regular expressions - Kleene star II",
    "id": "2258e5fb5df44f4abf65676be48874d7"
  },
  {
    "data-question": {
      "type": "give-equivalent",
      "text": "Construct a finite state machine which accepts the language defined by the expression <b>abb(abb)*</b>",
      "allowEpsilon": "true",
      "splitSymbol": "",
      "targetMachineSpec": {
        "nodes": [
          {
            "id": "A",
            "x": 104,
            "y": 103,
            "isInit": true
          },
          {
            "id": "B",
            "x": 192,
            "y": 54
          },
          {
            "id": "C",
            "x": 274,
            "y": 111
          },
          {
            "id": "D",
            "x": 187,
            "y": 160,
            "isAcc": true
          }
        ],
        "links": [
          {
            "to": "B",
            "from": "A",
            "input": [
              "a"
            ]
          },
          {
            "to": "C",
            "from": "B",
            "input": [
              "b"
            ]
          },
          {
            "to": "D",
            "from": "C",
            "input": [
              "b"
            ]
          },
          {
            "to": "A",
            "from": "D",
            "hasEps": true
          }
        ],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": true
        }
      }
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 100,
            "y": 125,
            "isInit": true
          }
        ],
        "links": [],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": true
        }
      }
    ],
    "data-options": {},
    "filename": "give-equivalent-abb",
    "name": "Regular expressions - abb(abb)*",
    "id": "c542b17ff0054febbab7543b44f636c8"
  },
  {
    "data-question": {
      "type": "give-input",
      "text": "<b>Transducers</b> are Finite State Machines which have <b>output</b>. <br>The machine below has an input alphabet of {a, b} and an output alphabet of {F, M, S}. <br>Give it an input such that its output is the string \"FSM\".",
      "allowEpsilon": "false",
      "splitSymbol": "",
      "target": "output",
      "outputSequence": [
        "F",
        "S",
        "M"
      ]
    },
    "data-machinelist": [
      {
        "nodes": [
          {
            "id": "A",
            "x": 105,
            "y": 175,
            "isInit": true
          },
          {
            "id": "B",
            "x": 205,
            "y": 175
          },
          {
            "id": "C",
            "x": 291,
            "y": 125
          },
          {
            "id": "D",
            "x": 295,
            "y": 218
          },
          {
            "id": "E",
            "x": 381,
            "y": 168,
            "isAcc": true
          }
        ],
        "links": [
          {
            "to": "B",
            "from": "A",
            "input": [
              "b"
            ],
            "output": {
              "b": "F"
            }
          },
          {
            "to": "A",
            "from": "A",
            "input": [
              "a"
            ],
            "output": {
              "a": "M"
            }
          },
          {
            "to": "C",
            "from": "B",
            "input": [
              "a"
            ],
            "output": {
              "a": "S"
            }
          },
          {
            "to": "C",
            "from": "C",
            "input": [
              "a"
            ]
          },
          {
            "to": "D",
            "from": "B",
            "input": [
              "b"
            ]
          },
          {
            "to": "E",
            "from": "D",
            "input": [
              "a"
            ],
            "output": {
              "a": "M"
            }
          },
          {
            "to": "E",
            "from": "C",
            "input": [
              "b"
            ],
            "output": {
              "b": "M"
            }
          },
          {
            "to": "E",
            "from": "E",
            "input": [
              "a",
              "b"
            ]
          }
        ],
        "attributes": {
          "alphabet": [
            "a",
            "b"
          ],
          "allowEpsilon": false,
          "isMealy": true
        }
      }
    ],
    "data-options": {},
    "filename": "intro-to-transducers.html",
    "name": "Introducing transducers",
    "id": "8f345a9adf1e47a8a517e4a25a42dbf3"
  }
]